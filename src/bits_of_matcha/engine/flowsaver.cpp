#include "bits_of_matcha/engine/flowsaver.h"
#include "bits_of_matcha/engine/node.h"
#include "bits_of_matcha/engine/nodeserializer.h"
#include "bits_of_matcha/engine/tensor.h"
#include "bits_of_matcha/engine/flow.h"
#include "bits_of_matcha/tensor.h"

#include <vector>
#include <set>
#include <map>


namespace matcha {
namespace engine {


void FlowSaver::save(std::ostream& os, const Flow* flow) {
  FlowSaver(os, flow);
}

FlowSaver::FlowSaver(std::ostream& os, const Flow* flow)
  : os_{os}
  , flow_{flow}
{
  for (auto& out: flow->outs_) {
    schedule(out.object());
  }

  os << "@matcha 0.0.0" << "\n\n";
  os << "/*\n"
        " * This file has been generated by the matcha engine.\n"
        " * Use Flow::load(\"thisFile.matcha\") to load it.\n"
        " */\n\n\n";

  os << "// flow ins" << "\n\n";
  while (!tensorQueue_.empty()) {
    declareTensor(os, tensorQueue_.front());
    tensorQueue_.pop();
  }

  os << "\n\n"
     << "// flow logic" << "\n\n";

  while (!nodeQueue_.empty()) {
    auto* node = nodeQueue_.front();
    nodeQueue_.pop();

    nodeSerializer.save(os, node);
  }

  os << "\n"
     << "// flow outs" << "\n\n";

  os << "yield ";
  for (int i = 0; i < flow->outs(); i++) {
    if (i != 0) os << ", ";
    os << flow->out(i).object()->name();
  }
}

void FlowSaver::schedule(Node* node) {
  if (scheduledNodes_.contains(node)) return;
  scheduledNodes_.insert(node);

  for (auto& in: node->ins_) {
    schedule(in);
  }
  nodeQueue_.push(node);
}

void FlowSaver::schedule(Tensor* tensor) {
  if (scheduledTensors_.contains(tensor)) return;
  scheduledTensors_.insert(tensor);

  if (tensor->in_ == nullptr) {
    tensorQueue_.push(tensor);
  } else {
    schedule(tensor->in_);
  }
}

void FlowSaver::tuple(std::ostream& os, const std::vector<std::string>& names) {
  for (int i = 0; i < names.size(); i++) {
    if (i != 0) os << ", ";
    os << names[i];
  }
}

void FlowSaver::tuple(std::ostream& os, const std::vector<Object*>& objects) {
  for (int i = 0; i < objects.size(); i++) {
    if (i != 0) os << ", ";
    os << objects[i]->name();
  }
}

void FlowSaver::indent(std::ostream& os) {
}

void FlowSaver::assignment(std::ostream& os, const std::vector<std::string>& lvalues, const std::string& assignmentSymbol) {
  if (lvalues.empty()) throw std::runtime_error("lvalues must not be empty");
  for (int i = 0; i < lvalues.size(); i++) {
    if (i != 0) os << ", ";
    os << lvalues[i];
  }
  os << assignmentSymbol;
}

void FlowSaver::declareTensor(std::ostream& os, Tensor* tensor) {
    assignment(os, tensor->name(), " = ");
    dtype(os, tensor->dtype());
    shape(os, tensor->shape());
    os << '\n';
}

void FlowSaver::assignment(std::ostream& os, const std::string& lvalue, const std::string& assignmentSymbol) {
  using namespace std;
  assignment(os, vector<string>{lvalue}, assignmentSymbol);
}

void FlowSaver::connection(std::ostream& os, const std::string& in, const std::vector<std::string>& outs) {
  os << in << " ==> ";
  tuple(os, outs);
  os << "\n";
}

void FlowSaver::connection(std::ostream& os, Node* in, const std::vector<Tensor*>& outs) {
  os << "*" + in->name() << " ==> ";
  std::vector<Object*> outsObj(outs.begin(), outs.end());
  tuple(os, outsObj);
  os << "\n";
}

void FlowSaver::dtype(std::ostream& os, const Dtype& dtype) {
  os << dtype.string();
}

void FlowSaver::shape(std::ostream& os, const Shape& shape) {
  os << "[";
  for (int i = 0; i < shape.rank(); i++) {
    if (i != 0) os << ", ";
    os << shape[i];
  }
  os << "]";
}

void FlowSaver::saveIns(std::ostream& os, const std::vector<Tensor*>& ins) {
  if (ins.empty()) return;

  os << "(";
  for (int i = 0; i < ins.size(); i++) {
    if (i != 0) os << ", ";
    os << ins[i]->name();
  }
  os << ")";
}

void FlowSaver::oneFloat(std::ostream& os, float value) {
  os << value;
}

void FlowSaver::flatFloats(std::ostream& os, const float* buffer, const Shape& shape, unsigned indent) {
  std::string indentString(2 * indent, ' ');
  size_t size = shape.size();
  if (shape.rank() < 2) {
    os << "{";
    for (size_t i = 0; i < size; i++) {
      if (i != 0) os << " ";
      os << buffer[i];
    }
    os << "}";
    return;
  }

  os << "{";
  size_t lineSize = shape[-1];
  size_t blockSize = shape[-1] * shape[-2];
  for (size_t i = 0; i < size; i++) {
    if (i % blockSize == 0) {
      if (i != 0) os << '\n';
    }
    if (i % lineSize == 0) os << "\n" << indentString << "  ";
    else os << " ";
    os << buffer[i];
  }
  os << "\n" << indentString << "}";
}

}
}
